
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>五、支持向量机 · HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 5.1.4">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, user-scalable=yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="6.html" />
    
    
    <link rel="prev" href="4.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="0.html">
            
                <a href="0.html">
            
                    
                    零、前言
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="1.html">
            
                <a href="1.html">
            
                    
                    一、机器学习概览
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="2.html">
            
                <a href="2.html">
            
                    
                    二、端到端的机器学习项目
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="3.html">
            
                <a href="3.html">
            
                    
                    三、分类
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="4.html">
            
                <a href="4.html">
            
                    
                    四、训练模型
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.7" data-path="5.html">
            
                <a href="5.html">
            
                    
                    五、支持向量机
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="6.html">
            
                <a href="6.html">
            
                    
                    六、决策树
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="7.html">
            
                <a href="7.html">
            
                    
                    七、集成学习和随机森林
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="8.html">
            
                <a href="8.html">
            
                    
                    八、降维
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="10.html">
            
                <a href="10.html">
            
                    
                    十、使用 Keras 搭建人工神经网络
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="11.html">
            
                <a href="11.html">
            
                    
                    十一、训练深度神经网络
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="12.html">
            
                <a href="12.html">
            
                    
                    十二、使用 TensorFlow 自定义模型并训练
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="13.html">
            
                <a href="13.html">
            
                    
                    十三、使用 TensorFlow 加载和预处理数据
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="14.html">
            
                <a href="14.html">
            
                    
                    十四、使用卷积神经网络实现深度计算机视觉
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="15.html">
            
                <a href="15.html">
            
                    
                    十五、使用 RNN 和 CNN 处理序列
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17" data-path="16.html">
            
                <a href="16.html">
            
                    
                    十六、使用 RNN 和注意力机制进行自然语言处理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.18" data-path="17.html">
            
                <a href="17.html">
            
                    
                    十七、使用自编码器和 GAN 做表征学习和生成式学习
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.19" data-path="18.html">
            
                <a href="18.html">
            
                    
                    十八、强化学习
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.20" data-path="19.html">
            
                <a href="19.html">
            
                    
                    十九、规模化训练和部署 TensorFlow 模型
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >五、支持向量机</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="五、支持向量机">五、支持向量机</h1>
<blockquote>
<p>译者：<a href="https://github.com/QiaoXie" target="_blank">@QiaoXie</a></p>
<p>校对者：<a href="https://github.com/wizardforcel" target="_blank">@飞龙</a>、<a href="https://github.com/PeterHo" target="_blank">@PeterHo</a>、<a href="https://github.com/yanmengk" target="_blank">@yanmengk</a>、<a href="https://github.com/bigeyex" target="_blank">@YuWang</a></p>
</blockquote>
<p>支持向量机（SVM）是个非常强大并且有多种功能的机器学习模型，能够做线性或者非线性的分类，回归，甚至异常值检测。机器学习领域中最为流行的模型之一，是任何学习机器学习的人必备的工具。SVM 特别适合应用于复杂但中小规模数据集的分类问题。</p>
<p>本章节将阐述支持向量机的核心概念，怎么使用这个强大的模型，以及它是如何工作的。</p>
<h2 id="线性支持向量机分类">线性支持向量机分类</h2>
<p>SVM 的基本思想能够用一些图片来解释得很好，图 5-1 展示了我们在第 4 章结尾处介绍的鸢尾花数据集的一部分。这两个种类能够被非常清晰，非常容易的用一条直线分开（即线性可分的）。左边的图显示了三种可能的线性分类器的判定边界。其中用虚线表示的线性模型判定边界很差，甚至不能正确地划分类别。另外两个线性模型在这个数据集表现的很好，但是它们的判定边界很靠近样本点，在新的数据上可能不会表现的很好。相比之下，右边图中 SVM 分类器的判定边界实线，不仅分开了两种类别，而且还尽可能地远离了最靠近的训练数据点。你可以认为 SVM 分类器在两种类别之间保持了一条尽可能宽敞的街道（图中平行的虚线），其被称为最大间隔分类。</p>
<p><img src="img/5-1.jpg" alt=""></img></p>
<p>我们注意到添加更多的样本点在“街道”外并不会影响到判定边界，因为判定边界是由位于“街道”边缘的样本点确定的，这些样本点被称为“支持向量”（图 5-1 中被圆圈圈起来的点）</p>
<blockquote>
<p>警告</p>
<p>SVM 对特征缩放比较敏感，可以看到图 5-2：左边的图中，垂直的比例要更大于水平的比例，所以最宽的“街道”接近水平。但对特征缩放后（例如使用 Scikit-Learn 的 StandardScaler），判定边界看起来要好得多，如右图。</p>
</blockquote>
<p><img src="img/5-2.jpg" alt=""></img></p>
<h3 id="软间隔分类">软间隔分类</h3>
<p>如果我们严格地规定所有的数据都不在“街道”上，都在正确地两边，称为硬间隔分类，硬间隔分类有两个问题，第一，只对线性可分的数据起作用，第二，对异常点敏感。图 5-3 显示了只有一个异常点的鸢尾花数据集：左边的图中很难找到硬间隔，右边的图中判定边界和我们之前在图 5-1 中没有异常点的判定边界非常不一样，它很难一般化。</p>
<p><img src="img/5-3.jpg" alt=""></img></p>
<p>为了避免上述的问题，我们更倾向于使用更加软性的模型。目的在保持“街道”尽可能大和避免间隔违规（例如：数据点出现在“街道”中央或者甚至在错误的一边）之间找到一个良好的平衡。这就是软间隔分类。</p>
<p>在 Scikit-Learn 库的 SVM 类，你可以用<code>C</code>超参数（惩罚系数）来控制这种平衡：较小的<code>C</code>会导致更宽的“街道”，但更多的间隔违规。图 5-4 显示了在非线性可分隔的数据集上，两个软间隔 SVM 分类器的判定边界。左边图中，使用了较大的<code>C</code>值，导致更少的间隔违规，但是间隔较小。右边的图，使用了较小的<code>C</code>值，间隔变大了，但是许多数据点出现在了“街道”上。然而，第二个分类器似乎泛化地更好：事实上，在这个训练数据集上减少了预测错误，因为实际上大部分的间隔违规点出现在了判定边界正确的一侧。</p>
<p><img src="img/5-4.jpg" alt=""></img></p>
<blockquote>
<p>提示</p>
<p>如果你的 SVM 模型过拟合，你可以尝试通过减小超参数<code>C</code>去调整。 </p>
</blockquote>
<p>以下的 Scikit-Learn 代码加载了内置的鸢尾花（Iris）数据集，缩放特征，并训练一个线性 SVM 模型（使用<code>LinearSVC</code>类，超参数<code>C=1</code>，hinge 损失函数）来检测 Virginica 鸢尾花，生成的模型在图 5-4 的右图。</p>
<pre><code class="lang-py"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> datasets
<span class="hljs-keyword">from</span> sklearn.pipeline <span class="hljs-keyword">import</span> Pipeline
<span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler
<span class="hljs-keyword">from</span> sklearn.svm <span class="hljs-keyword">import</span> LinearSVC

iris = datasets.load_iris()
X = iris[<span class="hljs-string">"data"</span>][:, (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)] <span class="hljs-comment"># petal length, petal width</span>
y = (iris[<span class="hljs-string">"target"</span>] == <span class="hljs-number">2</span>).astype(np.float64) <span class="hljs-comment"># Iris-Virginica</span>

svm_clf = Pipeline((
        (<span class="hljs-string">"scaler"</span>, StandardScaler()),
        (<span class="hljs-string">"linear_svc"</span>, LinearSVC(C=<span class="hljs-number">1</span>, loss=<span class="hljs-string">"hinge"</span>)),
    ))

svm_clf.fit(X, y)

Then, <span class="hljs-keyword">as</span> usual, you can use the model to make predictions:

<span class="hljs-meta">&gt;&gt;&gt; </span>svm_clf.predict([[<span class="hljs-number">5.5</span>, <span class="hljs-number">1.7</span>]])
array([ <span class="hljs-number">1.</span>])
</code></pre>
<blockquote>
<p>注</p>
<p>不同于 Logistic 回归分类器，SVM 分类器不会输出每个类别的概率。</p>
</blockquote>
<p>作为一种选择，你可以在 SVC 类，使用<code>SVC(kernel="linear", C=1)</code>，但是它比较慢，尤其在较大的训练集上，所以一般不被推荐。另一个选择是使用<code>SGDClassifier</code>类，即<code>SGDClassifier(loss="hinge", alpha=1/(m*C))</code>。它应用了随机梯度下降（SGD 见第四章）来训练一个线性 SVM 分类器。尽管它不会和<code>LinearSVC</code>一样快速收敛，但是对于处理那些不适合放在内存的大数据集是非常有用的，或者处理在线分类任务同样有用。</p>
<blockquote>
<p>提示</p>
<p><code>LinearSVC</code>要使偏置项规范化，首先你应该集中训练集减去它的平均数。如果你使用了<code>StandardScaler</code>，那么它会自动处理。此外，确保你设置<code>loss</code>参数为<code>hinge</code>，因为它不是默认值。最后，为了得到更好的效果，你需要将<code>dual</code>参数设置为<code>False</code>，除非特征数比样本量多（我们将在本章后面讨论二元性）</p>
</blockquote>
<h2 id="非线性支持向量机分类">非线性支持向量机分类</h2>
<p>尽管线性 SVM 分类器在许多案例上表现得出乎意料的好，但是很多数据集并不是线性可分的。一种处理非线性数据集方法是增加更多的特征，例如多项式特征（正如你在第 4 章所做的那样）；在某些情况下可以变成线性可分的数据。在图 5-5 的左图中，它只有一个特征<code>x1</code>的简单的数据集，正如你看到的，该数据集不是线性可分的。但是如果你增加了第二个特征 <code>x2=(x1)^2</code>，产生的 2D 数据集就能很好的线性可分。</p>
<p><img src="img/5-5.jpg" alt=""></img></p>
<p>为了实施这个想法，通过 Scikit-Learn，你可以创建一个流水线（Pipeline）去包含多项式特征（PolynomialFeatures）变换（在 121 页的“Polynomial Regression”中讨论），然后一个<code>StandardScaler</code>和<code>LinearSVC</code>。让我们在卫星数据集（moons datasets）测试一下效果。</p>
<pre><code class="lang-py"><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> make_moons
<span class="hljs-keyword">from</span> sklearn.pipeline <span class="hljs-keyword">import</span> Pipeline
<span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> PolynomialFeatures

polynomial_svm_clf = Pipeline((
        (<span class="hljs-string">"poly_features"</span>, PolynomialFeatures(degree=<span class="hljs-number">3</span>)),
        (<span class="hljs-string">"scaler"</span>, StandardScaler()),
        (<span class="hljs-string">"svm_clf"</span>, LinearSVC(C=<span class="hljs-number">10</span>, loss=<span class="hljs-string">"hinge"</span>))
    ))

polynomial_svm_clf.fit(X, y)
</code></pre>
<p><img src="img/5-6.jpg" alt=""></img></p>
<h3 id="多项式核">多项式核</h3>
<p>添加多项式特征很容易实现，不仅仅在 SVM，在各种机器学习算法都有不错的表现，但是低次数的多项式不能处理非常复杂的数据集，而高次数的多项式却产生了大量的特征，会使模型变得慢。</p>
<p>幸运的是，当你使用 SVM 时，你可以运用一个被称为“核技巧”（kernel trick）的神奇数学技巧。它可以取得就像你添加了许多多项式，甚至有高次数的多项式，一样好的结果。所以不会大量特征导致的组合爆炸，因为你并没有增加任何特征。这个技巧可以用 SVC 类来实现。让我们在卫星数据集测试一下效果。</p>
<pre><code class="lang-py"><span class="hljs-keyword">from</span> sklearn.svm <span class="hljs-keyword">import</span> SVC
poly_kernel_svm_clf = Pipeline((
        (<span class="hljs-string">"scaler"</span>, StandardScaler()),
        (<span class="hljs-string">"svm_clf"</span>, SVC(kernel=<span class="hljs-string">"poly"</span>, degree=<span class="hljs-number">3</span>, coef0=<span class="hljs-number">1</span>, C=<span class="hljs-number">5</span>))
    ))
poly_kernel_svm_clf.fit(X, y)
</code></pre>
<p>这段代码用 3 阶的多项式核训练了一个 SVM 分类器，即图 5-7 的左图。右图是使用了 10 阶的多项式核 SVM 分类器。很明显，如果你的模型过拟合，你可以减小多项式核的阶数。相反的，如果是欠拟合，你可以尝试增大它。超参数<code>coef0</code>控制了高阶多项式与低阶多项式对模型的影响。</p>
<p><img src="img/5-7.jpg" alt=""></img></p>
<p>通用的方法是用网格搜索（grid search 见第 2 章）去找到最优超参数。首先进行非常粗略的网格搜索一般会很快，然后在找到的最佳值进行更细的网格搜索。对每个超参数的作用有一个很好的理解可以帮助你在正确的超参数空间找到合适的值。</p>
<h3 id="增加相似特征">增加相似特征</h3>
<p>另一种解决非线性问题的方法是使用相似函数（similarity funtion）计算每个样本与特定地标（landmark）的相似度。例如，让我们来看看前面讨论过的一维数据集，并在<code>x1=-2</code>和<code>x1=1</code>之间增加两个地标（图 5-8 左图）。接下来，我们定义一个相似函数，即高斯径向基函数（Gaussian Radial Basis Function，RBF），设置<code>γ = 0.3</code>（见公式 5-1）</p>
<p>公式 5-1 RBF</p>
<p><img src="img/tex-8b908429a5b5ee2e519f8caa16f82ee1.gif" alt=""></img></p>
<p>它是个从 0 到 1 的钟型函数，值为 0 的离地标很远，值为 1 的在地标上。现在我们准备计算新特征。例如，我们看一下样本<code>x1=-1</code>：它距离第一个地标距离是 1，距离第二个地标是 2。因此它的新特征为<code>x2=exp(-0.3 × (1^2))≈0.74</code>和<code>x3=exp(-0.3 × (2^2))≈0.30</code>。图 5-8 右边的图显示了特征转换后的数据集（删除了原始特征），正如你看到的，它现在是线性可分了。</p>
<p><img src="img/5-8.jpg" alt=""></img></p>
<p>你可能想知道如何选择地标。最简单的方法是在数据集中的每一个样本的位置创建地标。这将产生更多的维度从而增加了转换后数据集是线性可分的可能性。但缺点是，<code>m</code>个样本，<code>n</code>个特征的训练集被转换成了<code>m</code>个实例，<code>m</code>个特征的训练集（假设你删除了原始特征）。这样一来，如果你的训练集非常大，你最终会得到同样大的特征。</p>
<h3 id="高斯-rbf-核">高斯 RBF 核</h3>
<p>就像多项式特征法一样，相似特征法对各种机器学习算法同样也有不错的表现。但是在所有额外特征上的计算成本可能很高，特别是在大规模的训练集上。然而，“核” 技巧再一次显现了它在 SVM 上的神奇之处：高斯核让你可以获得同样好的结果成为可能，就像你在相似特征法添加了许多相似特征一样，但事实上，你并不需要在 RBF 添加它们。我们使用 SVC 类的高斯 RBF 核来检验一下。</p>
<pre><code class="lang-py">rbf_kernel_svm_clf = Pipeline((
        (<span class="hljs-string">"scaler"</span>, StandardScaler()),
        (<span class="hljs-string">"svm_clf"</span>, SVC(kernel=<span class="hljs-string">"rbf"</span>, gamma=<span class="hljs-number">5</span>, C=<span class="hljs-number">0.001</span>))
    ))
rbf_kernel_svm_clf.fit(X, y)
</code></pre>
<p>这个模型在图 5-9 的左下角表示。其他的图显示了用不同的超参数<code>gamma (γ)</code>和<code>C</code>训练的模型。增大<code>γ</code>使钟型曲线更窄（图 5-8 左图），导致每个样本的影响范围变得更小：即判定边界最终变得更不规则，在单个样本周围环绕。相反的，较小的<code>γ</code>值使钟型曲线更宽，样本有更大的影响范围，判定边界最终则更加平滑。所以γ是可调整的超参数：如果你的模型过拟合，你应该减小<code>γ</code>值，若欠拟合，则增大<code>γ</code>（与超参数<code>C</code>相似）。</p>
<p><img src="img/5-9.jpg" alt=""></img></p>
<p>还有其他的核函数，但很少使用。例如，一些核函数是专门用于特定的数据结构。在对文本文档或者 DNA 序列进行分类时，有时会使用字符串核（String kernels）（例如，使用 SSK 核（string subsequence kernel）或者基于编辑距离（Levenshtein distance）的核函数）。</p>
<blockquote>
<p>提示</p>
<p>这么多可供选择的核函数，你如何决定使用哪一个？一般来说，你应该先尝试线性核函数（记住<code>LinearSVC</code>比<code>SVC(kernel="linear")</code>要快得多），尤其是当训练集很大或者有大量的特征的情况下。如果训练集不太大，你也可以尝试高斯径向基核（Gaussian RBF Kernel），它在大多数情况下都很有效。如果你有空闲的时间和计算能力，你还可以使用交叉验证和网格搜索来试验其他的核函数，特别是有专门用于你的训练集数据结构的核函数。</p>
</blockquote>
<h3 id="计算复杂性">计算复杂性</h3>
<p><code>LinearSVC</code>类基于<code>liblinear</code>库，它实现了线性 SVM 的优化算法。它并不支持核技巧，但是它样本和特征的数量几乎是线性的：训练时间复杂度大约为<code>O(m × n)</code>。</p>
<p>如果你要非常高的精度，这个算法需要花费更多时间。这是由容差值超参数<code>ϵ</code>（在 Scikit-learn 称为<code>tol</code>）控制的。大多数分类任务中，使用默认容差值的效果是已经可以满足一般要求。</p>
<p>SVC 类基于<code>libsvm</code>库，它实现了支持核技巧的算法。训练时间复杂度通常介<code>于 O(m^2 × n)</code>和<code>O(m^3 × n)</code>之间。不幸的是，这意味着当训练样本变大时，它将变得极其慢（例如，成千上万个样本）。这个算法对于复杂但小型或中等数量的数据集表现是完美的。然而，它能对特征数量很好的缩放，尤其对稀疏特征来说（sparse features）（即每个样本都有一些非零特征）。在这个情况下，算法对每个样本的非零特征的平均数量进行大概的缩放。表 5-1 对 Scikit-learn 的 SVM 分类模型进行比较。</p>
<p><img src="img/tb-5-1.jpg" alt=""></img></p>
<h2 id="svm-回归">SVM 回归</h2>
<p>正如我们之前提到的，SVM 算法应用广泛：不仅仅支持线性和非线性的分类任务，还支持线性和非线性的回归任务。技巧在于逆转我们的目标：限制间隔违规的情况下，不是试图在两个类别之间找到尽可能大的“街道”（即间隔）。SVM 回归任务是限制间隔违规情况下，尽量放置更多的样本在“街道”上。“街道”的宽度由超参数<code>ϵ</code>控制。图 5-10 显示了在一些随机生成的线性数据上，两个线性 SVM 回归模型的训练情况。一个有较大的间隔（<code>ϵ=1.5</code>），另一个间隔较小（<code>ϵ=0.5</code>）。</p>
<p><img src="img/5-10.jpg" alt=""></img></p>
<p>添加更多的数据样本在间隔之内并不会影响模型的预测，因此，这个模型认为是不敏感的（ϵ-insensitive）。</p>
<p>你可以使用 Scikit-Learn 的<code>LinearSVR</code>类去实现线性 SVM 回归。下面的代码产生的模型在图 5-10 左图（训练数据需要被中心化和标准化）</p>
<pre><code class="lang-py"><span class="hljs-keyword">from</span> sklearn.svm <span class="hljs-keyword">import</span> LinearSVR
svm_reg = LinearSVR(epsilon=<span class="hljs-number">1.5</span>)
svm_reg.fit(X, y)
</code></pre>
<p>处理非线性回归任务，你可以使用核化的 SVM 模型。比如，图 5-11 显示了在随机二次方的训练集，使用二次方多项式核函数的 SVM 回归。左图是较小的正则化（即更大的<code>C</code>值），右图则是更大的正则化（即小的<code>C</code>值）</p>
<p><img src="img/5-11.jpg" alt=""></img></p>
<p>下面的代码的模型在图 5-11，其使用了 Scikit-Learn 的<code>SVR</code>类（支持核技巧）。在回归任务上，<code>SVR</code>类和<code>SVC</code>类是一样的，并且<code>LinearSVR</code>是和<code>LinearSVC</code>等价。<code>LinearSVR</code>类和训练集的大小成线性（就像<code>LinearSVC</code>类），当训练集变大，<code>SVR</code>会变的很慢（就像<code>SVC</code>类）</p>
<pre><code class="lang-py"><span class="hljs-keyword">from</span> sklearn.svm <span class="hljs-keyword">import</span> SVR

svm_poly_reg = SVR(kernel=<span class="hljs-string">"poly"</span>, degree=<span class="hljs-number">2</span>, C=<span class="hljs-number">100</span>, epsilon=<span class="hljs-number">0.1</span>)
svm_poly_reg.fit(X, y)
</code></pre>
<blockquote>
<p>注</p>
<p>SVM 也可以用来做异常值检测，详情见 Scikit-Learn 文档</p>
</blockquote>
<h2 id="背后机制">背后机制</h2>
<p>这个章节从线性 SVM 分类器开始，将解释 SVM 是如何做预测的并且算法是如何工作的。如果你是刚接触机器学习，你可以跳过这个章节，直接进入本章末尾的练习。等到你想深入了解 SVM，再回头研究这部分内容。</p>
<p>首先，关于符号的约定：在第 4 章，我们将所有模型参数放在一个向量<code>θ</code>里，包括偏置项<code>θ0</code>，<code>θ1</code>到<code>θn</code>的输入特征权重，和增加一个偏差输入<code>x0 = 1</code>到所有样本。在本章中，我们将使用一个不同的符号约定，在处理 SVM 上，这更方便，也更常见：偏置项被命名为<code>b</code>，特征权重向量被称为<code>w</code>，在输入特征向量中不再添加偏置特征。</p>
<h3 id="决策函数和预测">决策函数和预测</h3>
<p>线性 SVM 分类器通过简单地计算决策函数<code>w · x + b = w[1] x[1] + ... + w[n] x[n] + b</code>来预测新样本的类别：如果结果是正的，预测类别<code>ŷ</code>是正类，为 1，否则他就是负类，为 0。见公式 5-2</p>
<p><img src="img/eq-5-2.gif" alt=""></img></p>
<p>图 5-12 显示了和图 5-4 右边图模型相对应的决策函数：因为这个数据集有两个特征（花瓣的宽度和花瓣的长度），所以是个二维的平面。决策边界是决策函数等于 0 的点的集合，图中两个平面的交叉处，即一条直线（图中的实线）</p>
<p><img src="img/5-12.jpg" alt=""></img></p>
<p>虚线表示的是那些决策函数等于 1 或 -1 的点：它们平行，且到决策边界的距离相等，形成一个间隔。训练线性 SVM 分类器意味着找到<code>w</code>值和<code>b</code>值使得这一个间隔尽可能大，同时避免间隔违规（硬间隔）或限制它们（软间隔）</p>
<h3 id="训练目标">训练目标</h3>
<p>看下决策函数的斜率：它等于权重向量的范数<code>||w||</code>。如果我们把这个斜率除于 2，决策函数等于 ±1 的点将会离决策边界原来的两倍大。换句话，即斜率除于 2，那么间隔将增加两倍。在图 5-13 中，2D 形式比较容易可视化。权重向量<code>w</code>越小，间隔越大。</p>
<p><img src="img/5-13.jpg" alt=""></img></p>
<p>所以我们的目标是最小化<code>||w||</code>，从而获得大的间隔。然而，如果我们想要避免间隔违规（硬间隔），对于正的训练样本，我们需要决策函数大于 1，对于负训练样本，小于 -1。若我们对负样本（即<code>y^(i) = 0</code>）定义<code>t^(i) = -1</code>，对正样本（即<code>y^(i) = 1</code>）定义<code>t^(i) = 1</code>，那么我们可以对所有的样本表示为<code>t^(i) (w^T x^(i) + b) &gt; 1</code>。</p>
<p>因此，我们可以将硬间隔线性 SVM 分类器表示为公式 5-3 中的约束优化问题</p>
<p><img src="img/eq-5-3.gif" alt=""></img></p>
<blockquote>
<p>注</p>
<p><code>1/2 w^T w</code>等于<code>1/2 |w|^2</code>，我们最小化<code>1/2 w^T w</code>，而不是最小化<code>|w|</code>。这会给我们相同的结果（因为最小化<code>w</code>值和<code>b</code>值，也是最小化该值一半的平方），但是<code>1/2 |w|^2</code>有很好又简单的导数（只有<code>w</code>），<code>|w|</code>在<code>w=0</code>处是不可微的。优化算法在可微函数表现得更好。</p>
</blockquote>
<p>为了获得软间隔的目标，我们需要对每个样本应用一个松弛变量（slack variable）<code>ζ^(i) &gt; 0</code>。<code>ζ^(i)</code>表示了第<code>i</code>个样本允许违规间隔的程度。我们现在有两个不一致的目标：一个是使松弛变量尽可能的小，从而减小间隔违规，另一个是使<code>1/2 w·w</code>尽量小，从而增大间隔。这时<code>C</code>超参数发挥作用：它允许我们在两个目标之间权衡。我们得到了公式 5-4 的约束优化问题。</p>
<p><img src="img/eq-5-4.gif" alt=""></img></p>
<h3 id="二次规划">二次规划</h3>
<p>硬间隔和软间隔都是线性约束的凸二次规划优化问题。这些问题被称之为二次规划（QP）问题。现在有许多解决方案可以使用各种技术来处理 QP 问题，但这超出了本书的范围。一般问题的公式在公式 5-5 给出。</p>
<p><img src="img/eq-5-5.gif" alt=""></img></p>
<p>注意到表达式<code>Ap ≤ b</code>实际上定义了<code>n[c]</code>约束：</p>
<p><img src="img/tex-660caa34698a6b22aaae14095ab6b077.gif" alt=""></img></p>
<p><code>a^(i)</code>是个包含了<code>A</code>的第<code>i</code>行元素的向量，<code>b^(i)</code>是<code>b</code>的第<code>i</code>个元素。 </p>
<p>可以很容易地看到，如果你用以下的方式设置 QP 的参数，你将获得硬间隔线性 SVM 分类器的目标：</p>
<ul>
<li><code>n[p] = n + 1</code>，<code>n</code>表示特征的数量（+1 是偏置项）</li>
<li><code>n[c] = m</code>，<code>m</code>表示训练样本数量</li>
<li><code>H</code>是<code>n[p] * n[p]</code>单位矩阵，除了左上角为 0（忽略偏置项）</li>
<li><code>f = 0</code>，一个全为 0 的<code>n[p]</code>维向量</li>
<li><code>b = 1</code>，一个全为 1 的<code>n[c]</code>维向量</li>
<li><code>a^(i) = -t^(i) x_dot^(i)</code>，<code>x_dot^(i)</code>等于<code>x^(i)</code>带一个额外的偏置特征<code>x_dot[0] = 1</code></li>
</ul>
<p>所以训练硬间隔线性 SVM 分类器的一种方式是使用现有的 QP 解决方案，即上述的参数。由此产生的向量<code>p</code>将包含偏置项<code>b = p[0]</code>和特征权重<code>w[i] = p[i] (i=1,2,...m)</code>。同样的，你可以使用 QP 解决方案来解决软间隔问题（见本章最后的练习）</p>
<p>然而，使用核技巧我们将会看到一个不同的约束优化问题。</p>
<h3 id="对偶问题">对偶问题</h3>
<p>给出一个约束优化问题，即原始问题（primal problem），它可能表示不同但是和另一个问题紧密相连，称为对偶问题（Dual Problem）。对偶问题的解通常是对原始问题的解给出一个下界约束，但在某些条件下，它们可以获得相同解。幸运的是，SVM 问题恰好满足这些条件，所以你可以选择解决原始问题或者对偶问题，两者将会有相同解。公式 5-6 表示了线性 SVM 的对偶形式（如果你对怎么从原始问题获得对偶问题感兴趣，可以看下附录 C）</p>
<p><img src="img/eq-5-6.gif" alt=""></img></p>
<p>一旦你找到最小化公式的向量<code>α</code>（使用 QP 解决方案），你可以通过使用公式 5-7 的方法计算<code>w</code>和<code>b</code>，从而使原始问题最小化。</p>
<p><img src="img/eq-5-7.gif" alt=""></img></p>
<p>当训练样本的数量比特征数量小的时候，对偶问题比原始问题要快得多。更重要的是，它让核技巧成为可能，而原始问题则不然。那么这个核技巧是怎么样的呢？</p>
<h3 id="核化支持向量机">核化支持向量机</h3>
<p>假设你想把一个 2 次多项式变换应用到二维空间的训练集（例如卫星数据集），然后在变换后的训练集上训练一个线性 SVM 分类器。公式 5-8 显示了你想应用的 2 次多项式映射函数<code>ϕ</code>。 </p>
<p><img src="img/eq-5-8.gif" alt=""></img></p>
<p>注意到转换后的向量是 3 维的而不是 2 维。如果我们应用这个 2 次多项式映射，然后计算转换后向量的点积（见公式 5-9），让我们看下两个 2 维向量<code>a</code>和<code>b</code>会发生什么。</p>
<p><img src="img/eq-5-9.gif" alt=""></img></p>
<p>转换后向量的点积等于原始向量点积的平方：<code>φ(a)^T φ(b) = (a^T b)^2</code>.</p>
<p>关键点是：如果你应用转换<code>ϕ</code>到所有训练样本，那么对偶问题（见公式 5-6）将会包含点积<code>φ(x^(i))^T φ(x^(j))</code>。但如果<code>ϕ</code>像在公式 5-8 定义的 2 次多项式转换，那么你可以将这个转换后的向量点积替换成<code>(x^(i)^T x^(j))^2</code>。所以实际上你根本不需要对训练样本进行转换：仅仅需要在公式 5-6 中，将点积替换成它点积的平方。结果将会和你经过麻烦的训练集转换并拟合出线性 SVM 算法得出的结果一样，但是这个技巧使得整个过程在计算上面更有效率。这就是核技巧的精髓。</p>
<p>函数<code>K(a, b) = (a^T b)^2</code>被称为二次多项式核（polynomial kernel）。在机器学习，核函数是一个能计算点积的函数，并只基于原始向量<code>a</code>和<code>b</code>，不需要计算（甚至知道）转换<code>ϕ</code>。公式 5-10 列举了一些最常用的核函数。</p>
<p><img src="img/eq-5-10.gif" alt=""></img></p>
<blockquote>
<p>Mercer 定理</p>
<p>根据 Mercer 定理，如果函数<code>K(a, b)</code>满足一些 Mercer 条件的数学条件(<code>K</code>函数在参数内必须是连续，对称，即<code>K(a, b) = K(b, a)</code>，等)，那么存在函数<code>ϕ</code>，将<code>a</code>和<code>b</code>映射到另一个空间（可能有更高的维度），有<code>K(a, b) = ϕ(a)^T ϕ(b)</code>。所以你可以用<code>K</code>作为核函数，即使你不知道<code>ϕ</code>是什么。使用高斯核（Gaussian RBF kernel）情况下，它实际是将每个训练样本映射到无限维空间，所以你不需要知道是怎么执行映射的也是一件好事。</p>
<p>注意一些常用核函数（例如 Sigmoid 核函数）并不满足所有的 Mercer 条件，然而在实践中通常表现得很好。</p>
</blockquote>
<p>我们还有一个问题要解决。公式 5-7 展示了线性 SVM 分类器如何从对偶解到原始解，如果你应用了核技巧那么得到的公式会包含<code>φ(x^(i))</code>。事实上，<code>w</code>必须和<code>φ(x^(i))</code>有同样的维度，可能是巨大的维度或者无限的维度，所以你很难计算它。但怎么在不知道<code>w</code>的情况下做出预测？好消息是你可以将公式 5-7 的<code>w</code>代入到新的样本<code>x^(n)</code>的决策函数中，你会得到一个在输入向量之间只有点积的方程式。这时，核技巧将派上用场，见公式 5-11</p>
<p><img src="img/eq-5-11.gif" alt=""></img></p>
<p>注意到支持向量才满足<code>α(i)≠0</code>，做出预测只涉及计算为支持向量部分的输入样本<code>x^(n)</code>的点积，而不是全部的训练样本。当然，你同样也需要使用同样的技巧来计算偏置项<code>b</code>，见公式 5-12</p>
<p><img src="img/eq-5-12.gif" alt=""></img></p>
<p>如果你开始感到头痛，这很正常：因为这是核技巧一个不幸的副作用</p>
<h3 id="在线支持向量机">在线支持向量机</h3>
<p>在结束这一章之前，我们快速地了解一下在线 SVM 分类器（回想一下，在线学习意味着增量地学习，不断有新实例）。对于线性 SVM 分类器，一种方式是使用梯度下降（例如使用<code>SGDClassifire</code>）最小化代价函数，如从原始问题推导出的公式 5-13。不幸的是，它比基于 QP 方式收敛慢得多。</p>
<p><img src="img/eq-5-13.gif" alt=""></img></p>
<p>代价函数第一个和会使模型有一个小的权重向量<code>w</code>，从而获得一个更大的间隔。第二个和计算所有间隔违规的总数。如果样本位于“街道”上和正确的一边，或它与“街道”正确一边的距离成比例，则间隔违规等于 0。最小化保证了模型的间隔违规尽可能小并且少。</p>
<blockquote>
<p>Hinge 损失</p>
<p>函数<code>max(0, 1–t)</code>被称为 Hinge 损失函数（如下）。当<code>t≥1</code>时，Hinge 值为 0。如果<code>t&lt;1</code>,它的导数（斜率）为 -1，若<code>t&gt;1</code>，则等于 0。在<code>t=1</code>处，它是不可微的，但就像套索回归（Lasso Regression）（参见 130 页套索回归）一样，你仍然可以在<code>t=0</code>时使用梯度下降法（即 -1 到 0 之间任何值）</p>
<p><img src="img/5-hinge.jpg" alt=""></img></p>
</blockquote>
<p>我们也可以实现在线核化的 SVM。例如使用“增量和递减 SVM 学习”或者“在线和主动的快速核分类器”。但是，这些都是用 Matlab 和 C++ 实现的。对于大规模的非线性问题，你可能需要考虑使用神经网络（见第二部分）</p>
<h2 id="练习">练习</h2>
<ol>
<li><p>支持向量机背后的基本思想是什么</p>
</li>
<li><p>什么是支持向量</p>
</li>
<li><p>当使用 SVM 时，为什么标准化输入很重要？</p>
</li>
<li><p>分类一个样本时，SVM 分类器能够输出一个置信值吗？概率呢？</p>
</li>
<li><p>在一个有数百万训练样本和数百特征的训练集上，你是否应该使用 SVM 原始形式或对偶形式来训练一个模型？</p>
</li>
<li><p>假设你用 RBF 核来训练一个 SVM 分类器，如果对训练集欠拟合：你应该增大或者减小<code>γ</code>吗？调整参数<code>C</code>呢？</p>
</li>
<li><p>使用现有的 QP 解决方案，你应该怎么样设置 QP 参数（<code>H</code>，<code>f</code>，<code>A</code>，和<code>b</code>）去解决一个软间隔线性 SVM 分类器问题？</p>
</li>
<li><p>在一个线性可分的数据集训练一个<code>LinearSVC</code>，并在同一个数据集上训练一个<code>SVC</code>和<code>SGDClassifier</code>，看它们是否产生了大致相同效果的模型。</p>
</li>
<li><p>在 MNIST 数据集上训练一个 SVM 分类器。因为 SVM 分类器是二元的分类，你需要使用一对多（one-versus-all）来对 10 个数字进行分类。你可能需要使用小的验证集来调整超参数，以加快进程。最后你能达到多少准确度？</p>
</li>
<li><p>在加利福尼亚住宅（California housing）数据集上训练一个 SVM 回归模型</p>
</li>
</ol>
<p>这些练习的答案在附录 A。</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="4.html" class="navigation navigation-prev " aria-label="Previous page: 四、训练模型">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="6.html" class="navigation navigation-next " aria-label="Next page: 六、决策树">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"五、支持向量机","level":"1.7","depth":1,"next":{"title":"六、决策树","level":"1.8","depth":1,"path":"6.md","ref":"./6.md","articles":[]},"previous":{"title":"四、训练模型","level":"1.6","depth":1,"path":"4.md","ref":"./4.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"5.md","mtime":"2024-08-23T21:05:56.826Z","type":"markdown"},"gitbook":{"version":"5.1.4","time":"2024-08-24T12:29:35.670Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

